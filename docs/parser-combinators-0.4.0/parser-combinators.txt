-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight package providing commonly useful parser combinators
--   
--   Lightweight package providing commonly useful parser combinators.
@package parser-combinators
@version 0.4.0


-- | The module provides parser combinators defined for instances of
--   <a>Applicative</a> and <a>Alternative</a>. It also re-exports
--   functions that are commonly used in parsing from
--   <a>Control.Applicative</a> with additional parsing-related comments
--   added.
--   
--   Due to the nature of the <a>Applicative</a> and <a>Alternative</a>
--   abstractions, they are prone to memory leaks and not as efficient as
--   their monadic counterparts. Although all the combinators we provide in
--   this module are perfectly expressible in terms of <a>Applicative</a>
--   and <a>Alternative</a>, please prefer <a>Control.Monad.Combinators</a>
--   instead when possible.
--   
--   If you wish that the combinators that cannot return empty lists return
--   values of the <a>NonEmpty</a> data type, use the
--   <a>Control.Applicative.Combinators.NonEmpty</a> module.
--   
--   <h3>A note on backtracking</h3>
--   
--   Certain parsing libraries, such as Megaparsec, do not backtrack every
--   branch of parsing automatically for the sake of performance and better
--   error messages. They typically backtrack only “atomic” parsers, e.g.
--   those that match a token or several tokens in a row. To backtrack an
--   arbitrary complex parser/branch, a special combinator should be used,
--   typically called <tt>try</tt>. Combinators in this module are defined
--   in terms <a>Applicative</a> and <a>Alternative</a> operations. Being
--   quite abstract, they cannot know anything about inner workings of any
--   concrete parsing library, and so they cannot use <tt>try</tt>.
--   
--   The essential feature of the <a>Alternative</a> type class is the
--   <tt>(<a>&lt;|&gt;</a>)</tt> operator that allows to express choice. In
--   libraries that do not backtrack everything automatically, the choice
--   operator and everything that is build on top of it require the parser
--   on the left hand side to backtrack in order for the alternative branch
--   of parsing to be tried. Thus it is the responsibility of the
--   programmer to wrap more complex, composite parsers in <tt>try</tt> to
--   achieve correct behavior.
module Control.Applicative.Combinators

-- | An associative binary operation
(<|>) :: Alternative f => forall a. () => f a -> f a -> f a
infixl 3 <|>

-- | Zero or more.
many :: Alternative f => forall a. () => f a -> f [a]

-- | One or more.
some :: Alternative f => forall a. () => f a -> f [a]

-- | One or none.
optional :: Alternative f => f a -> f Maybe a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. () => f a

-- | <tt><a>between</a> open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces = between (symbol "{") (symbol "}")
--   </pre>
between :: Applicative m => m open -> m close -> m a -> m a

-- | <tt><a>choice</a> ps</tt> tries to apply the parsers in the list
--   <tt>ps</tt> in order, until one of them succeeds. Returns the value of
--   the succeeding parser.
--   
--   <pre>
--   choice = asum
--   </pre>
choice :: (Foldable f, Alternative m) => f (m a) -> m a

-- | <tt><a>count</a> n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>.
--   If <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt><a>pure</a> []</tt>. Returns a list of <tt>n</tt> parsed values.
--   
--   <pre>
--   count = replicateM
--   </pre>
--   
--   See also: <a>skipCount</a>, <a>count'</a>.
count :: Applicative m => Int -> m a -> m [a]

-- | <tt><a>count'</a> m n p</tt> parses from <tt>m</tt> to <tt>n</tt>
--   occurrences of <tt>p</tt>. If <tt>n</tt> is not positive or <tt>m &gt;
--   n</tt>, the parser equals to <tt><a>pure</a> []</tt>. Returns a list
--   of parsed values.
--   
--   Please note that <tt>m</tt> <i>may</i> be negative, in this case
--   effect is the same as if it were equal to zero.
--   
--   See also: <a>skipCount</a>, <a>count</a>.
count' :: Alternative m => Int -> Int -> m a -> m [a]

-- | Combine two alternatives.
--   
--   <pre>
--   eitherP a b = (Left &lt;$&gt; a) &lt;|&gt; (Right &lt;$&gt; b)
--   </pre>
eitherP :: Alternative m => m a -> m b -> m (Either a b)

-- | <tt><a>endBy</a> p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements = cStatement `endBy` semicolon
--   </pre>
endBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>endBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>manyTill</a> p end</tt> applies parser <tt>p</tt> <i>zero</i>
--   or more times until parser <tt>end</tt> succeeds. Returns the list of
--   values returned by <tt>p</tt>.
--   
--   See also: <a>skipMany</a>, <a>skipManyTill</a>.
manyTill :: Alternative m => m a -> m end -> m [a]

-- | <tt><a>someTill</a> p end</tt> works similarly to <tt><a>manyTill</a>
--   p end</tt>, but <tt>p</tt> should succeed at least once.
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill :: Alternative m => m a -> m end -> m [a]

-- | <tt><a>option</a> x p</tt> tries to apply the parser <tt>p</tt>. If
--   <tt>p</tt> fails without consuming input, it returns the value
--   <tt>x</tt>, otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   option x p = p &lt;|&gt; pure x
--   </pre>
--   
--   See also: <a>optional</a>.
option :: Alternative m => a -> m a -> m a

-- | <tt><a>sepBy</a> p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p = p `sepBy` comma
--   </pre>
sepBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>sepBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy</a> p sep</tt> parses <i>zero</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy1</a> p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt><a>skipMany</a> p</tt> applies the parser <tt>p</tt> <i>zero</i>
--   or more times, skipping its result.
--   
--   See also: <a>manyTill</a>, <a>skipManyTill</a>.
skipMany :: Alternative m => m a -> m ()

-- | <tt><a>skipSome</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times, skipping its result.
--   
--   See also: <a>someTill</a>, <a>skipSomeTill</a>.
skipSome :: Alternative m => m a -> m ()

-- | <tt><a>skipCount</a> n p</tt> parses <tt>n</tt> occurrences of
--   <tt>p</tt>, skipping its result. If <tt>n</tt> is not positive, the
--   parser equals to <tt><a>pure</a> []</tt>. Returns a list of <tt>n</tt>
--   values.
--   
--   <pre>
--   skipCount = replicateM_
--   </pre>
--   
--   See also: <a>count</a>, <a>count'</a>.
skipCount :: Applicative m => Int -> m a -> m ()

-- | <tt><a>skipManyTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>zero</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>manyTill</a>, <a>skipMany</a>.
skipManyTill :: Alternative m => m a -> m end -> m end

-- | <tt><a>skipSomeTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>one</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>someTill</a>, <a>skipSome</a>.
skipSomeTill :: Alternative m => m a -> m end -> m end


-- | The module provides <a>NonEmpty</a> list variants of some of the
--   functions from <a>Control.Applicative.Combinators</a>.
module Control.Applicative.Combinators.NonEmpty

-- | <tt><a>some</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times and returns a list of the values returned by <tt>p</tt>.
--   
--   <pre>
--   word = some letter
--   </pre>
some :: Alternative m => m a -> m (NonEmpty a)

-- | <tt><a>endBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a non-empty
--   list of values returned by <tt>p</tt>.
endBy1 :: Alternative m => m a -> m sep -> m (NonEmpty a)

-- | <tt><a>someTill</a> p end</tt> works similarly to <tt><a>manyTill</a>
--   p end</tt>, but <tt>p</tt> should succeed at least once.
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill :: Alternative m => m a -> m end -> m (NonEmpty a)

-- | <tt><a>sepBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a non-empty list of
--   values returned by <tt>p</tt>.
sepBy1 :: Alternative m => m a -> m sep -> m (NonEmpty a)

-- | <tt><a>sepEndBy1</a> p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a non-empty list of values returned by <tt>p</tt>.
sepEndBy1 :: Alternative m => m a -> m sep -> m (NonEmpty a)


-- | This module is a generalization of the package
--   <tt>parsec-permutation</tt> authored by Samuel Hoffstaetter:
--   
--   <a>https://hackage.haskell.org/package/parsec-permutation</a>
--   
--   This module also takes inspiration from the algorithm is described in:
--   <i>Parsing Permutation Phrases</i>, by Arthur Baars, Andres Loh and
--   Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
--   
--   From these two works we derive a flexible and general method for
--   parsing permutations over an <a>Applicative</a> structure. Quite
--   useful in conjunction with "Free" constructions of Applicatives,
--   Monads, etc.
--   
--   Other permutation parsing libraries tend towards using special "almost
--   applicative" combinators for construction which denies the library
--   user the ability to lift and unlift permutation parsing into any
--   <a>Applicative</a> computational context. We redefine these
--   combinators as convenience operators here alongside the equivalent
--   <a>Applicative</a> instance.
--   
--   For example, suppose we want to parse a permutation of: an optional
--   string of <tt>a</tt>'s, the character <tt>b</tt> and an optional
--   <tt>c</tt>. Using a standard parsing library combinator <tt>char</tt>,
--   this can be described using the <a>Applicative</a> instance by:
--   
--   <pre>
--   test = runPermutation $
--            (,,) &lt;$&gt; toPermutationWithDefault ""  (some (char 'a'))
--                 &lt;*&gt; toPermutation (char 'b')
--                 &lt;*&gt; toPermutationWithDefault '_' (char 'c')
--   </pre>
--   
--   Equivalently, this can also be describe using the convenience
--   operators reminiscent of other parsing libraries:
--   
--   <pre>
--   test = runPermutation $
--            (,,) &lt;$?&gt; ("", some (char 'a'))
--                 &lt;||&gt; char 'b'
--                 &lt;|?&gt; ('_', char 'c')
--   </pre>
module Control.Applicative.Permutations

-- | An <a>Applicative</a> wrapper-type for constructing permutation
--   parsers.
data Permutation m a

-- | "Unlifts" a permutation parser into a parser to be evaluated.
runPermutation :: (Alternative m, Monad m) => Permutation m a -> m a

-- | "Unlifts" a permutation parser into a parser to be evaluated with an
--   intercalated effect. Useful for separators between permutation
--   elements.
--   
--   For example, suppose that similar to above we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. <i>However</i>, we also want
--   each element of the permutation to be separated by a colon. Using a
--   standard parsing library combinator <tt>char</tt>, this can be
--   described using the <a>Applicative</a> instance by:
--   
--   <pre>
--   test = intercalateEffect (char ':') $
--            (,,) &lt;$?&gt; ("", some (char 'a'))
--                 &lt;||&gt; char 'b'
--                 &lt;|?&gt; ('_', char 'c')
--   </pre>
--   
--   This will accept strings such as: "a:b:c", "b:c:a", "b:aa", "b", etc.
--   
--   Note that the effect is intercalated <i>between</i> permutation
--   components and that:
--   
--   <ul>
--   <li>There is never an effect parsed preceeding the first component of
--   the permutation</li>
--   <li>There is never an effect parsed following the last component of
--   the permutation</li>
--   <li>No effects are intercalated between missing components with a
--   default value.</li>
--   </ul>
intercalateEffect :: (Alternative m, Monad m) => m b -> Permutation m a -> m a

-- | "Lifts" a parser to a permutation parser.
toPermutation :: Alternative m => m a -> Permutation m a

-- | "Lifts" a parser with a default value to a permutation parser.
--   
--   If no permutation containing the supplied parser can be parsed from
--   the input, then the supplied default value is returned in lieu of a
--   parse result.
toPermutationWithDefault :: Alternative m => a -> m a -> Permutation m a

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input—use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: Alternative m => (a -> b) -> m a -> Permutation m b
infixl 2 <$$>

-- | The expression <tt>f &lt;$?&gt; (x, p)</tt> creates a fresh
--   permutation parser consisting of parser <tt>p</tt>. The final result
--   of the permutation parser is the function <tt>f</tt> applied to the
--   return value of <tt>p</tt>. The parser <tt>p</tt> is optional—if it
--   cannot be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: Alternative m => (a -> b) -> (a, m a) -> Permutation m b
infixl 2 <$?>

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input—use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: Alternative m => Permutation m (a -> b) -> m a -> Permutation m b
infixl 1 <||>

-- | The expression <tt>perm &lt;||&gt; (x, p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional—if it cannot be applied, the default value <tt>x</tt> will be
--   used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: Alternative m => Permutation m (a -> b) -> (a, m a) -> Permutation m b
infixl 1 <|?>
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Applicative.Permutations.Permutation m)
instance GHC.Base.Alternative m => GHC.Base.Applicative (Control.Applicative.Permutations.Permutation m)


-- | The module provides more efficient versions of the combinators from
--   <a>Control.Applicative.Combinators</a> defined in terms of
--   <a>Monad</a> and <a>MonadPlus</a> instead of <a>Applicative</a> and
--   <a>Alternative</a>. When there is no difference in performance we just
--   re-export the combinators from <a>Control.Applicative.Combinators</a>.
module Control.Monad.Combinators

-- | An associative binary operation
(<|>) :: Alternative f => forall a. () => f a -> f a -> f a
infixl 3 <|>

-- | One or none.
optional :: Alternative f => f a -> f Maybe a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. () => f a

-- | <tt><a>between</a> open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces = between (symbol "{") (symbol "}")
--   </pre>
between :: Applicative m => m open -> m close -> m a -> m a

-- | <tt><a>choice</a> ps</tt> tries to apply the parsers in the list
--   <tt>ps</tt> in order, until one of them succeeds. Returns the value of
--   the succeeding parser.
--   
--   <pre>
--   choice = asum
--   </pre>
choice :: (Foldable f, Alternative m) => f (m a) -> m a

-- | <tt><a>count</a> n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>.
--   If <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt><a>return</a> []</tt>. Returns a list of <tt>n</tt> values.
--   
--   See also: <a>skipCount</a>, <a>count'</a>.
count :: Monad m => Int -> m a -> m [a]

-- | <tt><a>count'</a> m n p</tt> parses from <tt>m</tt> to <tt>n</tt>
--   occurrences of <tt>p</tt>. If <tt>n</tt> is not positive or <tt>m &gt;
--   n</tt>, the parser equals to <tt><a>return</a> []</tt>. Returns a list
--   of parsed values.
--   
--   Please note that <tt>m</tt> <i>may</i> be negative, in this case
--   effect is the same as if it were equal to zero.
--   
--   See also: <a>skipCount</a>, <a>count</a>.
count' :: MonadPlus m => Int -> Int -> m a -> m [a]

-- | Combine two alternatives.
--   
--   <pre>
--   eitherP a b = (Left &lt;$&gt; a) &lt;|&gt; (Right &lt;$&gt; b)
--   </pre>
eitherP :: Alternative m => m a -> m b -> m (Either a b)

-- | <tt><a>endBy</a> p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements = cStatement `endBy` semicolon
--   </pre>
endBy :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>endBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>many</a> p</tt> applies the parser <tt>p</tt> <i>zero</i> or
--   more times and returns a list of the values returned by <tt>p</tt>.
--   
--   <pre>
--   identifier = (:) &lt;$&gt; letter &lt;*&gt; many (alphaNumChar &lt;|&gt; char '_')
--   </pre>
many :: MonadPlus m => m a -> m [a]

-- | <tt><a>manyTill</a> p end</tt> applies parser <tt>p</tt> <i>zero</i>
--   or more times until parser <tt>end</tt> succeeds. Returns the list of
--   values returned by <tt>p</tt>.
--   
--   See also: <a>skipMany</a>, <a>skipManyTill</a>.
manyTill :: MonadPlus m => m a -> m end -> m [a]

-- | <tt><a>some</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times and returns a list of the values returned by <tt>p</tt>.
--   
--   <pre>
--   word = some letter
--   </pre>
some :: MonadPlus m => m a -> m [a]

-- | <tt><a>someTill</a> p end</tt> works similarly to <tt><a>manyTill</a>
--   p end</tt>, but <tt>p</tt> should succeed at least once.
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill :: MonadPlus m => m a -> m end -> m [a]

-- | <tt><a>option</a> x p</tt> tries to apply the parser <tt>p</tt>. If
--   <tt>p</tt> fails without consuming input, it returns the value
--   <tt>x</tt>, otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   option x p = p &lt;|&gt; pure x
--   </pre>
--   
--   See also: <a>optional</a>.
option :: Alternative m => a -> m a -> m a

-- | <tt><a>sepBy</a> p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p = p `sepBy` comma
--   </pre>
sepBy :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy</a> p sep</tt> parses <i>zero</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>sepEndBy1</a> p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a list of values returned by <tt>p</tt>.
sepEndBy1 :: MonadPlus m => m a -> m sep -> m [a]

-- | <tt><a>skipMany</a> p</tt> applies the parser <tt>p</tt> <i>zero</i>
--   or more times, skipping its result.
--   
--   See also: <a>manyTill</a>, <a>skipManyTill</a>.
skipMany :: MonadPlus m => m a -> m ()

-- | <tt><a>skipSome</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times, skipping its result.
--   
--   See also: <a>someTill</a>, <a>skipSomeTill</a>.
skipSome :: MonadPlus m => m a -> m ()

-- | <tt><a>skipCount</a> n p</tt> parses <tt>n</tt> occurrences of
--   <tt>p</tt>, skipping its result. If <tt>n</tt> is smaller or equal to
--   zero, the parser equals to <tt><a>return</a> []</tt>. Returns a list
--   of <tt>n</tt> values.
--   
--   See also: <a>count</a>, <a>count'</a>.
skipCount :: Monad m => Int -> m a -> m ()

-- | <tt><a>skipManyTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>zero</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>manyTill</a>, <a>skipMany</a>.
skipManyTill :: MonadPlus m => m a -> m end -> m end

-- | <tt><a>skipSomeTill</a> p end</tt> applies the parser <tt>p</tt>
--   <i>one</i> or more times skipping results until parser <tt>end</tt>
--   succeeds. Result parsed by <tt>end</tt> is then returned.
--   
--   See also: <a>someTill</a>, <a>skipSome</a>.
skipSomeTill :: MonadPlus m => m a -> m end -> m end


-- | The module provides <a>NonEmpty</a> list variants of some of the
--   functions from <a>Control.Monad.Combinators</a>.
module Control.Monad.Combinators.NonEmpty

-- | <tt><a>some</a> p</tt> applies the parser <tt>p</tt> <i>one</i> or
--   more times and returns a list of the values returned by <tt>p</tt>.
--   
--   <pre>
--   word = some letter
--   </pre>
some :: MonadPlus m => m a -> m (NonEmpty a)

-- | <tt><a>endBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a non-empty
--   list of values returned by <tt>p</tt>.
endBy1 :: MonadPlus m => m a -> m sep -> m (NonEmpty a)

-- | <tt><a>someTill</a> p end</tt> works similarly to <tt><a>manyTill</a>
--   p end</tt>, but <tt>p</tt> should succeed at least once.
--   
--   See also: <a>skipSome</a>, <a>skipSomeTill</a>.
someTill :: MonadPlus m => m a -> m end -> m (NonEmpty a)

-- | <tt><a>sepBy1</a> p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a non-empty list of
--   values returned by <tt>p</tt>.
sepBy1 :: MonadPlus m => m a -> m sep -> m (NonEmpty a)

-- | <tt><a>sepEndBy1</a> p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a non-empty list of values returned by <tt>p</tt>.
sepEndBy1 :: MonadPlus m => m a -> m sep -> m (NonEmpty a)
