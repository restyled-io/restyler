-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC.Generics-based Control.DeepSeq.rnf implementation
--   
--   This package provides a <a>GHC.Generics</a>-based
--   <a>Control.DeepSeq.Generics.genericRnf</a> function which can be used
--   for providing a <a>rnf</a> implementation. See the documentation for
--   the <a>genericRnf</a> function in the <a>Control.DeepSeq.Generics</a>
--   module to get started.
--   
--   The original idea was pioneered in the <tt>generic-deepseq</tt>
--   package (see
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2012-February/099551.html</a>
--   for more information).
--   
--   This package differs from the <tt>generic-deepseq</tt> package by
--   working in combination with the existing <tt>deepseq</tt> package as
--   opposed to defining a conflicting drop-in replacement for
--   <tt>deepseq</tt>'s <tt>Control.DeepSeq</tt> module.
--   
--   <b>Note</b>: The ability to auto-derive via <a>GHC.Generics</a> has
--   been merged into <tt>deepseq-1.4.0.0</tt>. This package is now still
--   useful for writing code that's also compatible with older
--   <tt>deepseq</tt> versions not yet providing
--   <a>GHC.Generics</a>-support.
@package deepseq-generics
@version 0.2.0.0


-- | <b>NOTE</b>: Starting with <tt>deepseq-1.4.0.0</tt>, <a>NFData</a>
--   gained support for generic derivation via <tt>DefaultSignatures</tt>.
--   The new default <a>rnf</a> method implementation is then equivalent to
--   
--   <pre>
--   instance NFData MyType where
--     <a>rnf</a> = <a>genericRnfV1</a>
--   </pre>
--   
--   See documentation of <a>rnf</a> for more details on how to use the new
--   built-in <a>Generic</a> support.
module Control.DeepSeq.Generics

-- | <a>GHC.Generics</a>-based <a>rnf</a> implementation
--   
--   This provides a generic <a>rnf</a> implementation for one type at a
--   time. If the type of the value <a>genericRnf</a> is asked to reduce to
--   NF contains values of other types, those types have to provide
--   <a>NFData</a> instances. This also means that recursive types can only
--   be used with <a>genericRnf</a> if a <a>NFData</a> instance has been
--   defined as well (see examples below).
--   
--   The typical usage for <a>genericRnf</a> is for reducing boilerplate
--   code when defining <a>NFData</a> instances for ordinary algebraic
--   datatypes. See the code below for some simple usage examples:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import Control.DeepSeq
--   import Control.DeepSeq.Generics (genericRnf)
--   import GHC.Generics
--   
--   -- simple record
--   data Foo = Foo AccountId Name Address
--            deriving Generic
--   
--   type Address      = [String]
--   type Name         = String
--   newtype AccountId = AccountId Int
--   
--   instance NFData AccountId
--   instance NFData Foo where rnf = genericRnf
--   
--   -- recursive list-like type
--   data N = Z | S N deriving Generic
--   
--   instance NFData N where rnf = genericRnf
--   
--   -- parametric &amp; recursive type
--   data Bar a = Bar0 | Bar1 a | Bar2 (Bar a)
--              deriving Generic
--   
--   instance NFData a =&gt; NFData (Bar a) where rnf = genericRnf
--   </pre>
--   
--   <b>NOTE</b>: The <a>GNFData</a> type-class showing up in the
--   type-signature is used internally and not exported.
genericRnf :: (Generic a, GNFData (Rep a)) => a -> ()

-- | Variant of <a>genericRnf</a> which supports derivation for uninhabited
--   types.
--   
--   For instance, the type
--   
--   <pre>
--   data TagFoo deriving Generic
--   </pre>
--   
--   would cause a compile-time error with <a>genericRnf</a>, but with
--   <a>genericRnfV1</a> the error is deferred to run-time:
--   
--   <pre>
--   Prelude&gt; genericRnf (undefined :: TagFoo)
--   
--   &lt;interactive&gt;:1:1:
--       No instance for (GNFData V1) arising from a use of `genericRnf'
--       Possible fix: add an instance declaration for (GNFData V1)
--       In the expression: genericRnf (undefined :: TagFoo)
--       In an equation for `it': it = genericRnf (undefined :: TagFoo)
--   
--   Prelude&gt; genericRnfV1 (undefined :: TagFoo)
--   *** Exception: Control.DeepSeq.Generics.genericRnfV1: uninhabited type
--   </pre>
--   
--   <a>genericRnfV1</a> corresponds to <tt>deepseq-1.4.0.0</tt>'s default
--   <tt>rnf</tt> method implementation.
--   
--   <b>NOTE</b>: The <a>GNFDataV1</a> type-class showing up in the
--   type-signature is used internally and not exported.
genericRnfV1 :: (Generic a, GNFDataV1 (Rep a)) => a -> ()
instance Control.DeepSeq.Generics.GNFDataV1 GHC.Generics.V1
instance Control.DeepSeq.Generics.GNFDataV1 GHC.Generics.U1
instance Control.DeepSeq.NFData a => Control.DeepSeq.Generics.GNFDataV1 (GHC.Generics.K1 i a)
instance Control.DeepSeq.Generics.GNFDataV1 a => Control.DeepSeq.Generics.GNFDataV1 (GHC.Generics.M1 i c a)
instance (Control.DeepSeq.Generics.GNFDataV1 a, Control.DeepSeq.Generics.GNFDataV1 b) => Control.DeepSeq.Generics.GNFDataV1 (a GHC.Generics.:*: b)
instance (Control.DeepSeq.Generics.GNFDataV1 a, Control.DeepSeq.Generics.GNFDataV1 b) => Control.DeepSeq.Generics.GNFDataV1 (a GHC.Generics.:+: b)
instance Control.DeepSeq.Generics.GNFData GHC.Generics.U1
instance Control.DeepSeq.NFData a => Control.DeepSeq.Generics.GNFData (GHC.Generics.K1 i a)
instance Control.DeepSeq.Generics.GNFData a => Control.DeepSeq.Generics.GNFData (GHC.Generics.M1 i c a)
instance (Control.DeepSeq.Generics.GNFData a, Control.DeepSeq.Generics.GNFData b) => Control.DeepSeq.Generics.GNFData (a GHC.Generics.:*: b)
instance (Control.DeepSeq.Generics.GNFData a, Control.DeepSeq.Generics.GNFData b) => Control.DeepSeq.Generics.GNFData (a GHC.Generics.:+: b)
