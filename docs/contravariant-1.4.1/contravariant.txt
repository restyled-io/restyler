-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Contravariant functors
--   
--   Contravariant functors.
@package contravariant
@version 1.4.1


-- | <a>Contravariant</a> functors, sometimes referred to colloquially as
--   <tt>Cofunctor</tt>, even though the dual of a <a>Functor</a> is just a
--   <a>Functor</a>. As with <a>Functor</a> the definition of
--   <a>Contravariant</a> for a given ADT is unambiguous.
module Data.Functor.Contravariant

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <pre>
--   contramap id = id
--   contramap f . contramap g = contramap (g . f)
--   </pre>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant f
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a

-- | If <tt>f</tt> is both <a>Functor</a> and <a>Contravariant</a> then by
--   the time you factor in the laws of each of those classes, it can't
--   actually use its argument in any meaningful capacity.
--   
--   This method is surprisingly useful. Where both instances exist and are
--   lawful we have the following laws:
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>phantom</a>
--   <a>contramap</a> f ≡ <a>phantom</a>
--   </pre>
phantom :: (Functor f, Contravariant f) => f a -> f b

-- | This is an infix alias for <a>contramap</a>
(>$<) :: Contravariant f => (a -> b) -> f b -> f a
infixl 4 >$<

-- | This is an infix version of <a>contramap</a> with the arguments
--   flipped.
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a
infixl 4 >$$<

-- | This is <a>&gt;$</a> with its arguments flipped.
($<) :: Contravariant f => f b -> b -> f a
infixl 4 $<
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool

-- | Defines a total ordering on a type as per <a>compare</a>
--   
--   This condition is not checked by the types. You must ensure that the
--   supplied values are valid total orderings yourself.
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering

-- | Compare using <a>compare</a>
defaultComparison :: Ord a => Comparison a

-- | This data type represents an equivalence relation.
--   
--   Equivalence relations are expected to satisfy three laws:
--   
--   <b>Reflexivity</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a a = True
--   </pre>
--   
--   <b>Symmetry</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a b = <a>getEquivalence</a> f b a
--   </pre>
--   
--   <b>Transitivity</b>:
--   
--   If <tt><a>getEquivalence</a> f a b</tt> and <tt><a>getEquivalence</a>
--   f b c</tt> are both <a>True</a> then so is <tt><a>getEquivalence</a> f
--   a c</tt>
--   
--   The types alone do not enforce these laws, so you'll have to check
--   them yourself.
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool

-- | Check for equivalence with <a>==</a>
--   
--   Note: The instances for <a>Double</a> and <a>Float</a> violate
--   reflexivity for <tt>NaN</tt>.
defaultEquivalence :: Eq a => Equivalence a
comparisonEquivalence :: Comparison a -> Equivalence a

-- | Dual function arrows.
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a
instance Control.Category.Category Data.Functor.Contravariant.Op
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a)
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Functor.Contravariant.Op a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence
instance Data.Semigroup.Semigroup (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison
instance Data.Semigroup.Semigroup (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate
instance Data.Semigroup.Semigroup (Data.Functor.Contravariant.Predicate a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Contravariant GHC.Generics.V1
instance Data.Functor.Contravariant.Contravariant GHC.Generics.U1
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Constant.Constant a)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Const.Const a)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Contravariant Data.StateVar.SettableStateVar
instance Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy


-- | This module supplies contravariant analogues to the <a>Applicative</a>
--   and <a>Alternative</a> classes.
module Data.Functor.Contravariant.Divisible

-- | A <a>Divisible</a> contravariant functor is the contravariant analogue
--   of <a>Applicative</a>.
--   
--   Continuing the intuition that <a>Contravariant</a> functors consume
--   input, a <a>Divisible</a> contravariant functor also has the ability
--   to be composed "beside" another contravariant functor.
--   
--   Serializers provide a good example of <a>Divisible</a> contravariant
--   functors. To begin let's start with the type of serializers for
--   specific types:
--   
--   <pre>
--   newtype Serializer a = Serializer { runSerializer :: a -&gt; ByteString }
--   </pre>
--   
--   This is a contravariant functor:
--   
--   <pre>
--   instance Contravariant Serializer where
--     contramap f s = Serializer (runSerializer s . f)
--   </pre>
--   
--   That is, given a serializer for <tt>a</tt> (<tt>s :: Serializer
--   a</tt>), and a way to turn <tt>b</tt>s into <tt>a</tt>s (a mapping
--   <tt>f :: b -&gt; a</tt>), we have a serializer for <tt>b</tt>:
--   <tt>contramap f s :: Serializer b</tt>.
--   
--   Divisible gives us a way to combine two serializers that focus on
--   different parts of a structure. If we postulate the existance of two
--   primitive serializers - <tt>string :: Serializer String</tt> and
--   <tt>int :: Serializer Int</tt>, we would like to be able to combine
--   these into a serializer for pairs of <tt>String</tt>s and
--   <tt>Int</tt>s. How can we do this? Simply run both serializer and
--   combine their output!
--   
--   <pre>
--   data StringAndInt = StringAndInt String Int
--   
--   stringAndInt :: Serializer StringAndInt
--   stringAndInt = Serializer $ (StringAndInt s i) -&gt;
--     let sBytes = runSerializer string s
--         iBytes = runSerializer int i
--     in sBytes &lt;&gt; iBytes
--   </pre>
--   
--   <a>divide</a> is a generalization by also taking a <a>contramap</a>
--   like function to split any <tt>a</tt> into a pair. This conveniently
--   allows you to target fields of a record, for instance, by extracting
--   the values under two fields and combining them into a tuple.
--   
--   To complete the example, here is how to write <tt>stringAndInt</tt>
--   using a <tt>Divisible</tt> instance:
--   
--   <pre>
--   instance Divisible Serializer where
--     conquer = Serializer (const mempty)
--   
--     divide toBC bSerializer cSerializer = Serializer $ a -&gt;
--       case toBC a of
--         (b, c) -&gt;
--           let bBytes = runSerializer bSerializer b
--               cBytes = runSerializer cSerializer c
--           in bBytes &lt;&gt; cBytes
--   
--   stringAndInt :: Serializer StringAndInt
--   stringAndInt =
--     divide ((StringAndInt s i) -&gt; (s, i)) string int
--   </pre>
class Contravariant f => Divisible f
divide :: Divisible f => (a -> (b, c)) -> f b -> f c -> f a

-- | Conquer acts as an identity for combining <tt>Divisible</tt> functors.
conquer :: Divisible f => f a

-- | <pre>
--   <a>divided</a> = <a>divide</a> <a>id</a>
--   </pre>
divided :: Divisible f => f a -> f b -> f (a, b)

-- | Redundant, but provided for symmetry.
--   
--   <pre>
--   <a>conquered</a> = <a>conquer</a>
--   </pre>
conquered :: Divisible f => f ()

-- | This is the divisible analogue of <a>liftA</a>. It gives a viable
--   default definition for <a>contramap</a> in terms of the members of
--   <a>Divisible</a>.
--   
--   <pre>
--   <a>liftD</a> f = <a>divide</a> ((,) () . f) <a>conquer</a>
--   </pre>
liftD :: Divisible f => (a -> b) -> f b -> f a

-- | A <a>Decidable</a> contravariant functor is the contravariant analogue
--   of <a>Alternative</a>.
--   
--   Noting the superclass constraint that <tt>f</tt> must also be
--   <a>Divisible</a>, a <tt>Decidable</tt> functor has the ability to "fan
--   out" input, under the intuition that contravariant functors consume
--   input.
--   
--   In the dicussion for <tt>Divisible</tt>, an example was demonstrated
--   with <tt>Serializer</tt>s, that turn <tt>a</tt>s into
--   <tt>ByteString</tt>s. <tt>Divisible</tt> allowed us to serialize the
--   <i>product</i> of multiple values by concatenation. By making our
--   <tt>Serializer</tt> also <tt>Decidable</tt>- we now have the ability
--   to serialize the <i>sum</i> of multiple values - for example different
--   constructors in an ADT.
--   
--   Consider serializing arbitrary identifiers that can be either
--   <tt>String</tt>s or <tt>Int</tt>s:
--   
--   <pre>
--   data Identifier = StringId String | IntId Int
--   </pre>
--   
--   We know we have serializers for <tt>String</tt>s and <tt>Int</tt>s,
--   but how do we combine them into a <tt>Serializer</tt> for
--   <tt>Identifier</tt>? Essentially, our <tt>Serializer</tt> needs to
--   scrutinise the incoming value and choose how to serialize it:
--   
--   <pre>
--   identifier :: Serializer Identifier
--   identifier = Serializer $ identifier -&gt;
--     case identifier of
--       StringId s -&gt; runSerializer string s
--       IntId i -&gt; runSerializer int i
--   </pre>
--   
--   It is exactly this notion of choice that <tt>Decidable</tt> encodes.
--   Hence if we add an instance of <tt>Decidable</tt> for
--   <tt>Serializer</tt>...
--   
--   <pre>
--   instance Decidable Serializer where
--     lose f = Serializer $ a -&gt; absurd (f a)
--     choose split l r = Serializer $ a -&gt;
--       either (runSerializer l) (runSerializer r) (split a)
--   </pre>
--   
--   Then our <tt>identifier</tt> <tt>Serializer</tt> is
--   
--   <pre>
--   identifier :: Serializer Identifier
--   identifier = choose toEither string int where
--     toEither (StringId s) = Left s
--     toEither (IntId i) = Right i
--   </pre>
class Divisible f => Decidable f

-- | Acts as identity to <a>choose</a>.
lose :: Decidable f => (a -> Void) -> f a
choose :: Decidable f => (a -> Either b c) -> f b -> f c -> f a

-- | <pre>
--   <a>chosen</a> = <a>choose</a> <a>id</a>
--   </pre>
chosen :: Decidable f => f b -> f c -> f (Either b c)

-- | <pre>
--   <a>lost</a> = <a>lose</a> <a>id</a>
--   </pre>
lost :: Decidable f => f Void
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Divisible.Decidable GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Decidable Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divisible.Decidable Data.StateVar.SettableStateVar
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Const.Const m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Divisible.Divisible GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Compose.Compose f g)
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Constant.Constant m)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divisible.Divisible Data.StateVar.SettableStateVar


-- | Composition of contravariant functors.
module Data.Functor.Contravariant.Compose

-- | Composition of two contravariant functors
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)

-- | Composition of covariant and contravariant functors
newtype ComposeFC f g a
ComposeFC :: f (g a) -> ComposeFC f g a
[getComposeFC] :: ComposeFC f g a -> f (g a)

-- | Composition of contravariant and covariant functors
newtype ComposeCF f g a
ComposeCF :: f (g a) -> ComposeCF f g a
[getComposeCF] :: ComposeCF f g a -> f (g a)
instance (Data.Functor.Contravariant.Contravariant f, GHC.Base.Functor g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (Data.Functor.Contravariant.Divisible.Divisible f, GHC.Base.Applicative g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.Compose f g)


module Data.Functor.Contravariant.Generic

-- | This provides machinery for deconstructing an arbitrary <a>Generic</a>
--   instance using a <a>Decidable</a> <a>Contravariant</a> functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare :: <a>Deciding</a> <a>Ord</a> a =&gt; a -&gt; a -&gt; <a>Ordering</a>
--   gcompare = <a>getComparison</a> $ <a>deciding</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> <a>compare</a>)
--   </pre>
--   
--   <pre>
--   geq :: <a>Deciding</a> <a>Eq</a> a =&gt; a -&gt; a -&gt; <a>Bool</a>
--   geq = <a>getEquivalence</a> $ <a>deciding</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>))
--   </pre>
class (Generic a, GDeciding q (Rep a)) => Deciding q a
deciding :: (Deciding q a, Decidable f) => p q -> (forall b. q b => f b) -> f a

-- | This provides machinery for deconstructing an arbitrary
--   <a>Generic1</a> instance using a <a>Decidable</a> <a>Contravariant</a>
--   functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare1 :: <a>Deciding1</a> <a>Ord</a> f =&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; f a -&gt; f a -&gt; <a>Ordering</a>
--   gcompare1 f = <a>getComparison</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> compare) (<a>Comparison</a> f)
--   </pre>
--   
--   <pre>
--   geq1 :: <a>Deciding1</a> <a>Eq</a> f =&gt; (a -&gt; a -&gt; <a>Bool</a>) -&gt; f a -&gt; f a -&gt; <a>Bool</a>
--   geq1 f = <a>getEquivalence</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>)) (<a>Equivalence</a> f)
--   </pre>
class (Generic1 t, GDeciding1 q (Rep1 t)) => Deciding1 q t
deciding1 :: (Deciding1 q t, Decidable f) => p q -> (forall b. q b => f b) -> f a -> f (t a)
instance (GHC.Generics.Generic1 t, Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.Rep1 t)) => Data.Functor.Contravariant.Generic.Deciding1 q t
instance Data.Functor.Contravariant.Generic.Deciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.V1
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f GHC.Generics.:*: g)
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f GHC.Generics.:+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.K1 i p)
instance Data.Functor.Contravariant.Generic.GDeciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.Par1
instance (GHC.Generics.Generic a, Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.Rep a)) => Data.Functor.Contravariant.Generic.Deciding q a
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.V1
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f GHC.Generics.:*: g)
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f GHC.Generics.:+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.K1 i p)
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) i (c :: GHC.Generics.Meta). Data.Functor.Contravariant.Generic.GDeciding q f => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.M1 i c f)
