-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities and combinators for parsing command line options
--   
--   optparse-applicative is a haskell library for parsing options on the
--   command line, providing a powerful applicative interface for composing
--   these options.
--   
--   optparse-applicative takes care of reading and validating the
--   arguments passed to the command line, handling and reporting errors,
--   generating a usage line, a comprehensive help screen, and enabling
--   context-sensitive bash completions.
--   
--   See the included README for detailed instructions and examples, which
--   is also available on github
--   <a>https://github.com/pcapriotti/optparse-applicative</a>.
@package optparse-applicative
@version 0.14.2.0

module Options.Applicative.Help.Levenshtein

-- | Calculate the Damerau-Levenshtein edit distance between two lists
--   (strings).
--   
--   This is modified from <a>https://wiki.haskell.org/Edit_distance</a>
--   and is originally from Lloyd Allison's paper "Lazy Dynamic-Programming
--   can be Eager"
--   
--   It's been changed though from Levenshtein to Damerau-Levenshtein,
--   which treats transposition of adjacent characters as one change
--   instead of two.
editDistance :: Eq a => [a] -> [a] -> Int

module Options.Applicative.Help.Pretty
(.$.) :: Doc -> Doc -> Doc

module Options.Applicative.Help.Chunk
mappendWith :: Monoid a => a -> a -> a -> a

-- | The free monoid on a semigroup <tt>a</tt>.
newtype Chunk a
Chunk :: Maybe a -> Chunk a
[unChunk] :: Chunk a -> Maybe a

-- | Given a semigroup structure on <tt>a</tt>, return a monoid structure
--   on 'Chunk a'.
--   
--   Note that this is <i>not</i> the same as <a>liftA2</a>.
chunked :: (a -> a -> a) -> Chunk a -> Chunk a -> Chunk a

-- | Concatenate a list into a Chunk. <a>listToChunk</a> satisfies:
--   
--   <pre>
--   isEmpty . listToChunk = null
--   listToChunk = mconcat . fmap pure
--   </pre>
listToChunk :: Monoid a => [a] -> Chunk a

-- | Concatenate two <a>Chunk</a>s with a space in between. If one is
--   empty, this just returns the other one.
--   
--   Unlike <a>&lt;+&gt;</a> for <a>Doc</a>, this operation has a unit
--   element, namely the empty <a>Chunk</a>.
(<<+>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate two <a>Chunk</a>s with a softline in between. This is
--   exactly like <a>&lt;&lt;+&gt;&gt;</a>, but uses a softline instead of
--   a space.
(<</>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically.
vcatChunks :: [Chunk Doc] -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically separated by empty lines.
vsepChunks :: [Chunk Doc] -> Chunk Doc

-- | Whether a <a>Chunk</a> is empty. Note that something like 'pure
--   mempty' is not considered an empty chunk, even though the underlying
--   <a>Doc</a> is empty.
isEmpty :: Chunk a -> Bool

-- | Convert a <a>String</a> into a <a>Chunk</a>. This satisfies:
--   
--   <pre>
--   isEmpty . stringChunk = null
--   extractChunk . stringChunk = string
--   </pre>
stringChunk :: String -> Chunk Doc

-- | Convert a paragraph into a <a>Chunk</a>. The resulting chunk is
--   composed by the words of the original paragraph separated by
--   softlines, so it will be automatically word-wrapped when rendering the
--   underlying document.
--   
--   This satisfies:
--   
--   <pre>
--   isEmpty . paragraph = null . words
--   </pre>
paragraph :: String -> Chunk Doc

-- | Part of a constrained comonad instance.
--   
--   This is the counit of the adjunction between <a>Chunk</a> and the
--   forgetful functor from monoids to semigroups. It satisfies:
--   
--   <pre>
--   extractChunk . pure = id
--   extractChunk . fmap pure = id
--   </pre>
extractChunk :: Monoid a => Chunk a -> a

-- | Display pairs of strings in a table.
tabulate :: [(Doc, Doc)] -> Chunk Doc
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Functor Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Applicative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Alternative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monad Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monoid a => Data.Semigroup.Semigroup (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.MonadPlus Options.Applicative.Help.Chunk.Chunk

module Options.Applicative.Help.Types
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc

-- | Convert a help text to <a>String</a>.
renderHelp :: Int -> ParserHelp -> String
instance GHC.Show.Show Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Monoid Options.Applicative.Help.Types.ParserHelp
instance Data.Semigroup.Semigroup Options.Applicative.Help.Types.ParserHelp

module Options.Applicative.Types
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | A single option of a parser.
data Option a
Option :: OptReader a -> OptProperties -> Option a

-- | reader for this option
[optMain] :: Option a -> OptReader a

-- | properties of this option
[optProps] :: Option a -> OptProperties
data OptName
OptShort :: !Char -> OptName
OptLong :: !String -> OptName

-- | An <a>OptReader</a> defines whether an option matches an command line
--   argument.
data OptReader a

-- | option reader
OptReader :: [OptName] -> (CReader a) -> (String -> ParseError) -> OptReader a

-- | flag reader
FlagReader :: [OptName] -> !a -> OptReader a

-- | argument reader
ArgReader :: (CReader a) -> OptReader a

-- | command reader
CmdReader :: (Maybe String) -> [String] -> (String -> Maybe (ParserInfo a)) -> OptReader a

-- | Specification for an individual parser option.
data OptProperties
OptProperties :: OptVisibility -> Chunk Doc -> String -> Maybe String -> Maybe (Doc -> Doc) -> OptProperties

-- | whether this flag is shown is the brief description
[propVisibility] :: OptProperties -> OptVisibility

-- | help text for this option
[propHelp] :: OptProperties -> Chunk Doc

-- | metavariable for this option
[propMetaVar] :: OptProperties -> String

-- | what to show in the help text as the default
[propShowDefault] :: OptProperties -> Maybe String

-- | a function to run over the brief description
[propDescMod] :: OptProperties -> Maybe (Doc -> Doc)

-- | Visibility of an option in the help text.
data OptVisibility

-- | does not appear in the help text at all
Internal :: OptVisibility

-- | only visible in the full description
Hidden :: OptVisibility

-- | visible both in the full and brief descriptions
Visible :: OptVisibility

-- | A newtype over 'ReaderT String Except', used by option readers.
newtype ReadM a
ReadM :: ReaderT String (Except ParseError) a -> ReadM a
[unReadM] :: ReadM a -> ReaderT String (Except ParseError) a

-- | Return the value being read.
readerAsk :: ReadM String

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a
data CReader a
CReader :: Completer -> ReadM a -> CReader a
[crCompleter] :: CReader a -> Completer
[crReader] :: CReader a -> ReadM a

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a
NilP :: (Maybe a) -> Parser a
OptP :: (Option a) -> Parser a
MultP :: (Parser (x -> a)) -> (Parser x) -> Parser a
AltP :: (Parser a) -> (Parser a) -> Parser a
BindP :: (Parser x) -> (x -> Parser a) -> Parser a
newtype ParserM r
ParserM :: (forall x. (r -> Parser x) -> Parser x) -> ParserM r
[runParserM] :: ParserM r -> forall x. (r -> Parser x) -> Parser x

-- | A shell complete function.
newtype Completer
Completer :: (String -> IO [String]) -> Completer
[runCompleter] :: Completer -> String -> IO [String]

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: (ParserFailure ParserHelp) -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
type Args = [String]

-- | Policy for how to handle options within the parse
data ArgPolicy

-- | The default policy, options and arguments can be interspersed. A `--`
--   option can be passed to ensure all following commands are treated as
--   arguments.
Intersperse :: ArgPolicy

-- | Options must all come before arguments, once a single positional
--   argument or subcommand is parsed, all remaining arguments are treated
--   as positionals. A `--` option can be passed if the first positional
--   one needs starts with <a>-</a>.
NoIntersperse :: ArgPolicy

-- | No options are parsed at all, all arguments are treated as
--   positionals. Is the policy used after `--` is encountered.
AllPositionals :: ArgPolicy

-- | Options and arguments can be interspersed, but if a given option is
--   not found, it is treated as a positional argument. This is sometimes
--   useful if one is passing through most options to another tool, but are
--   supplying just a few of their own options.
ForwardOptions :: ArgPolicy
data OptHelpInfo
OptHelpInfo :: Bool -> Bool -> Bool -> OptHelpInfo

-- | Whether this is part of a many or some (approximately)
[hinfoMulti] :: OptHelpInfo -> Bool

-- | Whether this option has a default value
[hinfoDefault] :: OptHelpInfo -> Bool

-- | If the result is a positional, if it can't be accessed in the current
--   parser position ( first arg )
[hinfoUnreachableArgs] :: OptHelpInfo -> Bool
data OptTree a
Leaf :: a -> OptTree a
MultNode :: [OptTree a] -> OptTree a
AltNode :: [OptTree a] -> OptTree a
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
data SomeParser
SomeParser :: (Parser a) -> SomeParser

-- | Subparser context, containing the <tt>name</tt> of the subparser, and
--   its parser info. Used by parserFailure to display relevant usage
--   information when parsing inside a subparser fails.
data Context
Context :: String -> (ParserInfo a) -> Context
data IsCmdStart
CmdStart :: IsCmdStart
CmdCont :: IsCmdStart
fromM :: ParserM a -> Parser a
oneM :: Parser a -> ParserM a
manyM :: Parser a -> ParserM [a]
someM :: Parser a -> ParserM [a]
optVisibility :: Option a -> OptVisibility
optMetaVar :: Option a -> String
optHelp :: Option a -> Chunk Doc
optShowDefault :: Option a -> Maybe String
optDescMod :: Option a -> Maybe (Doc -> Doc)
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.OptTree a)
instance GHC.Show.Show Options.Applicative.Types.OptHelpInfo
instance GHC.Classes.Eq Options.Applicative.Types.OptHelpInfo
instance GHC.Show.Show Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Ord Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Eq Options.Applicative.Types.ArgPolicy
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.ParserResult a)
instance GHC.Show.Show Options.Applicative.Types.OptVisibility
instance GHC.Classes.Ord Options.Applicative.Types.OptVisibility
instance GHC.Classes.Eq Options.Applicative.Types.OptVisibility
instance GHC.Show.Show Options.Applicative.Types.OptName
instance GHC.Classes.Ord Options.Applicative.Types.OptName
instance GHC.Classes.Eq Options.Applicative.Types.OptName
instance GHC.Show.Show Options.Applicative.Types.ParserPrefs
instance GHC.Classes.Eq Options.Applicative.Types.ParserPrefs
instance GHC.Show.Show Options.Applicative.Types.IsCmdStart
instance GHC.Base.Monad Options.Applicative.Types.ParserM
instance GHC.Base.Functor Options.Applicative.Types.ParserM
instance GHC.Base.Applicative Options.Applicative.Types.ParserM
instance GHC.Base.Monoid Options.Applicative.Types.ParseError
instance Data.Semigroup.Semigroup Options.Applicative.Types.ParseError
instance GHC.Base.Functor Options.Applicative.Types.ParserInfo
instance GHC.Show.Show (Options.Applicative.Types.Option a)
instance GHC.Base.Functor Options.Applicative.Types.Option
instance GHC.Base.Functor Options.Applicative.Types.ReadM
instance GHC.Base.Applicative Options.Applicative.Types.ReadM
instance GHC.Base.Alternative Options.Applicative.Types.ReadM
instance GHC.Base.Monad Options.Applicative.Types.ReadM
instance Control.Monad.Fail.MonadFail Options.Applicative.Types.ReadM
instance GHC.Base.MonadPlus Options.Applicative.Types.ReadM
instance GHC.Base.Functor Options.Applicative.Types.CReader
instance GHC.Base.Functor Options.Applicative.Types.OptReader
instance GHC.Base.Functor Options.Applicative.Types.Parser
instance GHC.Base.Applicative Options.Applicative.Types.Parser
instance GHC.Base.Alternative Options.Applicative.Types.Parser
instance GHC.Base.Functor Options.Applicative.Types.ParserResult
instance GHC.Base.Applicative Options.Applicative.Types.ParserResult
instance GHC.Base.Monad Options.Applicative.Types.ParserResult
instance GHC.Show.Show h => GHC.Show.Show (Options.Applicative.Types.ParserFailure h)
instance GHC.Base.Functor Options.Applicative.Types.ParserFailure
instance GHC.Show.Show Options.Applicative.Types.CompletionResult
instance Data.Semigroup.Semigroup Options.Applicative.Types.Completer
instance GHC.Base.Monoid Options.Applicative.Types.Completer
instance GHC.Show.Show Options.Applicative.Types.OptProperties

module Options.Applicative.Internal
data P a
class (Alternative m, MonadPlus m) => MonadP m
enterContext :: MonadP m => String -> ParserInfo a -> m ()
exitContext :: MonadP m => m ()
getPrefs :: MonadP m => m ParserPrefs
missingArgP :: MonadP m => ParseError -> Completer -> m a
tryP :: MonadP m => m a -> m (Either ParseError a)
errorP :: MonadP m => ParseError -> m a
exitP :: MonadP m => IsCmdStart -> ArgPolicy -> Parser b -> Maybe a -> m a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
uncons :: [a] -> Maybe (a, [a])
hoistMaybe :: MonadPlus m => Maybe a -> m a
hoistEither :: MonadP m => Either ParseError a -> m a
runReadM :: MonadP m => ReadM a -> String -> m a
withReadM :: (String -> String) -> ReadM a -> ReadM a
runP :: P a -> ParserPrefs -> (Either ParseError a, [Context])
data Completion a
runCompletion :: Completion r -> ParserPrefs -> Maybe (Either (SomeParser, ArgPolicy) Completer)
contextNames :: [Context] -> [String]
data ListT m a
takeListT :: Monad m => Int -> ListT m a -> ListT m a
runListT :: Monad m => ListT m a -> m [a]
data NondetT m a
cut :: Monad m => NondetT m ()
(<!>) :: Monad m => NondetT m a -> NondetT m a -> NondetT m a
disamb :: Monad m => Bool -> NondetT m a -> m (Maybe a)
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.NondetT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.NondetT
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.ListT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.ListT
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.ListT m)
instance GHC.Base.Functor Options.Applicative.Internal.Completion
instance GHC.Base.Applicative Options.Applicative.Internal.Completion
instance GHC.Base.Alternative Options.Applicative.Internal.Completion
instance GHC.Base.Monad Options.Applicative.Internal.Completion
instance GHC.Base.MonadPlus Options.Applicative.Internal.Completion
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.Completion
instance GHC.Base.Functor Options.Applicative.Internal.ComplResult
instance GHC.Base.Applicative Options.Applicative.Internal.ComplResult
instance GHC.Base.Monad Options.Applicative.Internal.ComplResult
instance GHC.Base.Functor Options.Applicative.Internal.P
instance GHC.Base.Applicative Options.Applicative.Internal.P
instance GHC.Base.Alternative Options.Applicative.Internal.P
instance GHC.Base.Monad Options.Applicative.Internal.P
instance GHC.Base.MonadPlus Options.Applicative.Internal.P
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.P

module Options.Applicative.Common

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Create a parser composed of a single option.
liftOpt :: Option a -> Parser a
showOption :: OptName -> String

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
runParserInfo :: MonadP m => ParserInfo a -> Args -> m a
runParserFully :: MonadP m => ArgPolicy -> Parser a -> Args -> m a

-- | Apply a <a>Parser</a> to a command line, and return a result and
--   leftover arguments. This function returns an error if any parsing
--   error occurs, or if any options are missing and don't have a default
--   value.
runParser :: MonadP m => ArgPolicy -> IsCmdStart -> Parser a -> Args -> m (a, Args)

-- | The default value of a <a>Parser</a>. This function returns an error
--   if any of the options don't have a default value.
evalParser :: Parser a -> Maybe a

-- | Map a polymorphic function over all the options of a parser, and
--   collect the results in a list.
mapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> [b]

-- | Like <a>mapParser</a>, but collect the results in a tree structure.
treeMapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> OptTree b
optionNames :: OptReader a -> [OptName]

module Options.Applicative.Help.Core

-- | Generate descriptions for commands.
cmdDesc :: Parser a -> [(Maybe String, Chunk Doc)]

-- | Generate a brief help text for a parser.
briefDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a brief help text for a parser, only including mandatory
--   options and arguments.
missingDesc :: ParserPrefs -> Parser a -> Chunk Doc
fold_tree :: OptTree (Chunk Doc) -> Chunk Doc

-- | Generate a full help text for a parser.
fullDesc :: ParserPrefs -> Parser a -> Chunk Doc
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
errorHelp :: Chunk Doc -> ParserHelp
headerHelp :: Chunk Doc -> ParserHelp
suggestionsHelp :: Chunk Doc -> ParserHelp
usageHelp :: Chunk Doc -> ParserHelp
bodyHelp :: Chunk Doc -> ParserHelp
footerHelp :: Chunk Doc -> ParserHelp

-- | Generate the help text for a program.
parserHelp :: ParserPrefs -> Parser a -> ParserHelp

-- | Generate option summary.
parserUsage :: ParserPrefs -> Parser a -> String -> Doc

module Options.Applicative.Help

module Options.Applicative.Builder.Internal

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a
Mod :: (f a -> f a) -> (DefaultProp a) -> (OptProperties -> OptProperties) -> Mod f a
class HasName f
name :: HasName f => OptName -> f a -> f a
class HasCompleter f
modCompleter :: HasCompleter f => (Completer -> Completer) -> f a -> f a
class HasValue f
hasValueDummy :: HasValue f => f a -> ()
class HasMetavar f
hasMetavarDummy :: HasMetavar f => f a -> ()
data OptionFields a
OptionFields :: [OptName] -> Completer -> (String -> ParseError) -> OptionFields a
[optNames] :: OptionFields a -> [OptName]
[optCompleter] :: OptionFields a -> Completer
[optNoArgError] :: OptionFields a -> String -> ParseError
data FlagFields a
FlagFields :: [OptName] -> a -> FlagFields a
[flagNames] :: FlagFields a -> [OptName]
[flagActive] :: FlagFields a -> a
data CommandFields a
CommandFields :: [(String, ParserInfo a)] -> Maybe String -> CommandFields a
[cmdCommands] :: CommandFields a -> [(String, ParserInfo a)]
[cmdGroup] :: CommandFields a -> Maybe String
data ArgumentFields a
ArgumentFields :: Completer -> ArgumentFields a
[argCompleter] :: ArgumentFields a -> Completer
data DefaultProp a
DefaultProp :: (Maybe a) -> (Maybe (a -> String)) -> DefaultProp a
optionMod :: (OptProperties -> OptProperties) -> Mod f a
fieldMod :: (f a -> f a) -> Mod f a

-- | Base default properties.
baseProps :: OptProperties
mkCommand :: Mod CommandFields a -> (Maybe String, [String], String -> Maybe (ParserInfo a))
mkParser :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Parser a
mkOption :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Option a
mkProps :: DefaultProp a -> (OptProperties -> OptProperties) -> OptProperties

-- | Hide this option from the help text
internal :: Mod f a
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.Mod f a)
instance Data.Semigroup.Semigroup (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.DefaultProp a)
instance Data.Semigroup.Semigroup (Options.Applicative.Builder.Internal.DefaultProp a)
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.CommandFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.FlagFields

module Options.Applicative.Builder.Completer

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer

module Options.Applicative.Builder

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Same as <a>option</a>.

-- | <i>Deprecated: Use <a>option</a> instead</i>
nullOption :: ReadM a -> Mod OptionFields a -> Parser a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a <a>Doc</a> value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | Hide this option from the brief description.
hidden :: Mod f a

-- | Hide this option from the help text
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style bold)
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to used
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser.
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a <a>Doc</a> value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a <a>Doc</a> value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a <a>Doc</a> value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a <a>Missing:</a> error and show the full usage
--   instead if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f
instance GHC.Base.Monoid Options.Applicative.Builder.PrefsMod
instance Data.Semigroup.Semigroup Options.Applicative.Builder.PrefsMod
instance GHC.Base.Monoid (Options.Applicative.Builder.InfoMod a)
instance Data.Semigroup.Semigroup (Options.Applicative.Builder.InfoMod a)


-- | You don't need to import this module to enable bash completion.
--   
--   See <a>the wiki</a> for more information on bash completion.
module Options.Applicative.BashCompletion
bashCompletionParser :: ParserInfo a -> ParserPrefs -> Parser CompletionResult
instance GHC.Show.Show Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Ord Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Eq Options.Applicative.BashCompletion.Richness

module Options.Applicative.Extra

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description in pure code.
--   
--   This function behaves like <a>execParser</a>, but can be called from
--   pure code. Note that, in case of errors, no message is displayed, and
--   this function simply returns <a>Nothing</a>.
--   
--   If you need to keep track of error messages, use <a>execParserPure</a>
--   instead.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
execParserMaybe :: ParserInfo a -> [String] -> Maybe a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | Run a program description with custom preferences in pure code.
--   
--   See <a>execParserMaybe</a> for details.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
customExecParserMaybe :: ParserPrefs -> ParserInfo a -> [String] -> Maybe a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo ShowHelpText mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: (ParserFailure ParserHelp) -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String

module Options.Applicative

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a <a>Doc</a> value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a

-- | Hide this option from the brief description.
hidden :: Mod f a

-- | Hide this option from the help text
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style bold)
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to used
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
mappend :: Monoid a => a -> a -> a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser.
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a <a>Doc</a> value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a <a>Doc</a> value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a <a>Doc</a> value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo ShowHelpText mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a <a>Missing:</a> error and show the full usage
--   instead if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: (ParserFailure ParserHelp) -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String


-- | This module contains an arrow interface for option parsers, which
--   allows to define and combine parsers using the arrow notation and
--   arrow combinators.
--   
--   The arrow syntax is particularly useful to create parsers of nested
--   structures, or records where the order of fields is different from the
--   order in which the parsers should be applied.
--   
--   For example, an <a>arguments</a> parser often needs to be applied
--   last, and that makes it inconvenient to use it for a field which is
--   not the last one in a record.
--   
--   Using the arrow syntax and the functions in this module, one can
--   write, e.g.:
--   
--   <pre>
--   data Options = Options
--     { optArgs :: [String]
--     , optVerbose :: Bool }
--   
--   opts :: Parser Options
--   opts = runA $ proc () -&gt; do
--     verbose &lt;- asA (switch (short 'v')) -&lt; ()
--     args &lt;- asA (arguments str idm) -&lt; ()
--     returnA -&lt; Options args verbose
--   </pre>
--   
--   Parser arrows, created out of regular <a>Parser</a> values using the
--   <a>asA</a> function, are arrows taking <tt>()</tt> as argument and
--   returning the parsed value.
module Options.Applicative.Arrows

-- | For any <a>Applicative</a> functor <tt>f</tt>, <tt>A f</tt> is the
--   <a>Arrow</a> instance associated to <tt>f</tt>.
--   
--   The <a>A</a> constructor can be used to convert a value of type <tt>f
--   (a -&gt; b)</tt> into an arrow.
newtype A f a b
A :: f (a -> b) -> A f a b
[unA] :: A f a b -> f (a -> b)

-- | Convert a value of type <tt>f a</tt> into an arrow taking <tt>()</tt>
--   as argument.
--   
--   Applied to a value of type <a>Parser</a>, it turns it into an arrow
--   that can be used inside an arrow command, or passed to arrow
--   combinators.
asA :: Applicative f => f a -> A f () a

-- | Convert an arrow back to an applicative value.
--   
--   This function can be used to return a result of type <a>Parser</a>
--   from an arrow command.
runA :: Applicative f => A f () a -> f a

-- | The type of arrows associated to the applicative <a>Parser</a>
--   functor.
type ParserA = A Parser
instance GHC.Base.Applicative f => Control.Category.Category (Options.Applicative.Arrows.A f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Options.Applicative.Arrows.A f)
